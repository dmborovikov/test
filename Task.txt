Тестовое задание (Linux).
Напишите сервис передачи файлов (сервер - C++ обязательно, клиент - произвольный язык).

Сервис будет состоять из двух компонент: 
    UDP сервер, который может получать данные, записывать их в память и вычислять от них контрольную сумму
    Клиент, который будет посылать данные серверу и сверять контрольную сумму

Клиент передаёт файл серверу. После получения файла сервер вычисляет его контрольную сумму и возвращает её клиенту.
Для передачи файла клиент разбивает его на пакеты специального формата и в произвольном порядке отправляет их серверу. После отправки всего файла, получает от сервера пакет с контрольной суммой файла и сравнивает полученную контрольную сумму с вычисленной самостоятельно. Контрольные суммы должны совпадать.


Для определённости контрольную сумму будем вычислять следующим образом:

#include <stddef.h>
#include <stdint.h>

uint32_t crc32c(uint32_t crc, const unsigned char *buf, size_t len)
{
  int k;

  crc = ~crc;
  while (len--) {
    crc ^= *buf++;
    for (k = 0; k < 8; k++)
      crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;
  }
  return ~crc;
}

 
Для взаимодействия клиента с сервером определим следующий формат заголовка пакетов:
uint32 seq_number // номер пакета
uint32 seq_total // количество пакетов с данными
uint8 type // тип пакета: 0 == ACK, 1 == PUT
byte id[8] // 8 байт - идентификатор, с которым будет записан файл
byte data[data_size] // после заголовка и до конца пакета идут данные

Максимальный размер UDP пакета примем 1472 байта.
Файл завершён, если seq_total равен количеству полученных пакетов с данными.

Рассмотрим 2 типа пакетов, определяемых числовым полем type:
PUT -- тип выставляется при отправке данных от клиента серверу
ACK -- тип выставляется при подтверждении получения

При формировании пакета PUT поле seq_number выставляется равным номеру текущего отправляемого пакета, а  seq_total выставляется равным необходимому числу пакетов, чтобы полностью передать файл для данного id. Остальная длина UDP пакета остаётся под данные.

При формировании пакета ACK: seq_number выставляется номеру полученного пакета, seq_total - общему числу полученных пакетов для данного id, поля id выставляются соответственно тем, которые были получены. Остальная длина UDP пакета не содержит ничего, за исключением специального случая.

Если сервер посчитал, что файл завершён, тогда он отправляет последний ACK пакет, и в секцию с данными записывает контрольную сумму. При этом на клиенте такой пакет обнаружить просто: его seq_total будет равен первоначально вычисленному необходимому числу пакетов для данного id.

Протокол взаимодействия будет следующий:
Клиент начинает отправлять данные серверу, используя пакеты типа PUT.
Сервер получает данные и записывает их в память, после каждого полученного пакета отправляя клиенту пакеты ACK.
Если клиент на какой-то отправленный пакет не получает ACK в течение таймаута, то отправленный пакет переотправляется. 

Требования к серверу:
    Передача данных клиентом серверу идемпотентна - пакеты с одним и тем же seq_number могут быть переотправлены несколько раз - это не нарушит ни целостность данных, ни поведение сервера
    Передача порций данных может идти в произвольном порядке (seq_number будет непоследовательный): 1 2 39 27 18 3 24 25 26 10 ... но сервер должен переупорядочить их и вычислить контрольную сумму корректно
    Между пакетами, относящимися к одному файлу, могут идти пакеты относящиеся к другому файлу: сервер должен записывать данные в память, соотнося пакеты с данным и отправлять ACK пакеты согласно всем полученным id

Требования к клиенту:
    Клиент должен специально отправлять пакеты в произвольном порядке.

Код выложите в репозиторий на github.com или любой другой сервис хранения репозиториев git, с публичной ссылкой.
В репозитории должен быть файл README, в котором написано как запускать клиент, как собирать и запускать сервер.
Также должен быть Makefile, который содержит цель run, которая выполняет действия, описанные в README и полностью демонстрирует работу сервиса:
    разбиение данных по пакетам
    отправку данных, соответствующих нескольким id от клиента к серверу с произвольным порядком следования пакетов
    получение данных сервером
    проверка успешности передачи - сверяем контрольные суммы
